¿Cuáles son las principales desventajas de JDBC, para las cuales JPA fue creada? Utilizar JDBC implica escribir código de difícil soporte: los códigos que utilizan JDBC son más verbosos y eso aumenta la dificultad de mantenimiento. JDBC aumenta el acoplamiento del código: el JDBC causa un acoplamiento mayor entre el código de la aplicación y la base de datos.

JDBC es un estándar de bajo nivel para interactuar con bases de datos. JPA es un estándar de alto nivel para el mismo propósito. JDBC es una API de bajo nivel, es decir, que está orientada a permitir ejecutar comandos SQL directamente y procesar los resultados obtenidos.

Java creó una especificación llamada JPA, API de persistencia de Java, que es la especificación para estandarizar el mapeo relacional de objetos en el mundo Java. Con JPA crea un estándar para que no seamos rehenes de una única biblioteca. Los frameworks y las bibliotecas comenzaron a implementar JPA en el código en lugar de importar las clases e interfaces de Hibernate. Comenzamos a usar JPA que es la especificación, por lo tanto la librería se convirtió en una implementación. Y para cambiar de implementación, solo necesitamos cambiarlo en jar y una u otra configuración. Pero el código en sí permanecía intacto y sin cambios, ya que no dependía de una implementación, sino de esta especificación JPA. Para trabajar con JPA, tenemos que elegir una de estas implementaciones, es decir no podemos utilizar JPA puro, porque JPA es una capa o una abstracción únicamente. Necesitamos a alguien que implemente los detalles con lo que las bibliotecas como hibernate o EclipseLink hacen ese trabajo.

¿Cuál es la diferencia entre Hibernate y JPA? JPA es una especificación y Hibernate es una de sus implementaciones.

¿Cuál es la mejor definición de una entidad en JPA? Es una clase que hace el mapeamiento de una tabla del banco de datos: una entidad JPA funciona como un espejo de una tabla en el banco de datos.

¿Cuáles tipos de atributos podemos mapear sin la necesidad de configuraciones adicionales vía anotaciones JPA? Los tipos primitivos, atributos del tipo String y algunas clases de Java, como LocalDate y BigDecimal. Esos tipos pueden ser mapeados automáticamente, sin la necesidad de configuraciones adicionales.

Aprendimos a utilizar la anotación @ManyToOne para indicar la cardinalidad de una relación. Cual es la cardinalidad default asumida por JPA, en el caso de un atributo que representa una relación y no tiene anotaciones? Es obligatorio agregar alguna anotación de cardinalidad en todos los atributos que representan relaciones. PA no asume una cardinalidad default cuando no colocamos anotaciones.

Ciclo de vida en JPA:
Cuando nosotros intentamos realizar la persistencia de la entidad producto con la entidad categoría, sin antes haber persistido la entidad categoría, es nos arrojó una excepción que era la excepción TransientPropertyValue. En él quería decir que nosotros estábamos intentando guardar un elemento que aún no existía en la base de datos, entonces para eso nosotros vamos a explicar en esta parte lo que son los ciclos de vida y los diferentes estudios en los que se puede encontrar una entidad. Y que a la hora de que nosotros estamos trabajando con el EntityManager, nosotros vamos a ir pasando de un estado a otro y eso va a ser lo que vamos a llamar el ciclo de vida. Entonces, inicialmente, cuando yo utilizo la palabra clave new, en una clase, esa entidad va a pasar a estar en un estado transiente. Esto significa que va a ser una entidad que ya fue instanciada pero no va a ser considerada para ser registrada en la base de datos. Entonces, todos los elementos que se encuentren como estado transiente JPA los va a ignorar y solamente va a trabajar con los elementos que se encuentran en el siguiente estado. El siguiente estado que nosotros vamos a tener es el estado Managed. En el estado Managed, nosotros para pasar a él tenemos que utilizar, tenemos que instanciar primero el EntityManager y persistir esa entidad que se encuentra como estado transiente. Cuando nosotros realizamos la persistencia pasamos de esa entidad al estado Managed o administrado. Todas las entidades que se encuentran con el estado Managed o administrado son entidades que cuentan como candidatas para ser registradas en la base de datos. Entonces luego de que yo hago el commit o el flush, yo envío efectivamente, sincronizo esos valores que fueron pasados como parámetro dentro de la entidad dentro de la base datos. O sea al yo realizar el commit o el flush, yo sincronizo mi base de datos, creo un nuevo id y genero un nuevo registro, una nueva fila en la base de datos. Luego de que yo he realizado el commit y el close, esa entidad para estar a un estado de detached. Entonces, el estado de detached es un estado donde se comporta similar al estado transiente y a quién JPA no lo reconoce o va desconsiderar todos los elementos que se encuentran como detached o separados. Entonces, todas las entidades que se encuentren en detached, JPA las va a ir ignorando y solamente va a ir trabajando, va actualizar registros de las entidades que se encuentran con el estado Managed o administrado.

¿Cuál es la finalidad del método merge? Traer los registros deseados con estado managed. Pero en una diferente ubicación en memoria, por lo que tenemos que reasignar la variable que se encuentra como detached.